from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import json
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Validate required environment variables
required_env_vars = ["OPENAI_API_KEY"]
missing_vars = [var for var in required_env_vars if not os.getenv(var)]

if missing_vars:
    print(f"[WARNING] Missing environment variables: {missing_vars}")
    print("   Some features may not work properly on Railway")
    print("   Set these in Railway Dashboard > Variables tab")
from agents.orchestrator import Orchestrator
from agents.enhanced_orchestrator import EnhancedOrchestrator
from services.sync_mongodb_user_service import SyncMongoDBUserService
from schemas.user import UserCredentials, UserProfile, Gender, ActivityLevel
from routes.intellectual import router as intellectual_router
from routes.food import router as food_router
# Using MongoDB Atlas for data storage

app = FastAPI(title="Mindscroll AI Health Pipeline", version="1.0.0")

# Health check endpoint for Railway
@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "Mindscroll Backend"}

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Frontend URLs
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include intellectual routes
app.include_router(intellectual_router, prefix="/api/intellectual", tags=["intellectual"])

# Include food routes
app.include_router(food_router, prefix="/api/food", tags=["food"])

# Initialize services with MongoDB
user_service = SyncMongoDBUserService()
orchestrator = Orchestrator()
enhanced_orchestrator = EnhancedOrchestrator()

print("[SUCCESS] Connected to MongoDB Atlas - All data will be stored in the cloud!")

# Pydantic models for request/response
class UserData(BaseModel):
    meals: List[str]
    exercises: List[str]
    lifestyle: Dict[str, Any]

class SignupRequest(BaseModel):
    # Basic Info
    email: str
    password: str
    name: str
    age: int
    gender: Gender
    weight: float
    height: float
    activity_level: ActivityLevel
    
    # Health Goals
    primary_health_goal: str
    motivation: Optional[str] = None
    lifestyle_vision: Optional[str] = None
    
    # Intellectual Interests
    intellectual_interests: List[str]
    learning_style: str
    time_availability: str
    
    # Personalization (will be generated by AI)
    nickname: Optional[str] = None
    avatar: Optional[str] = None

class LoginRequest(BaseModel):
    email: str
    password: str

class DailyEntryRequest(BaseModel):
    user_id: str
    meals: List[str]
    exercises: List[str]
    lifestyle: Dict[str, Any]

class ProfileUpdateRequest(BaseModel):
    user_id: str
    name: Optional[str] = None
    age: Optional[int] = None
    gender: Optional[Gender] = None
    weight: Optional[float] = None
    height: Optional[float] = None
    activity_level: Optional[ActivityLevel] = None
    primary_health_goal: Optional[str] = None
    motivation: Optional[str] = None
    lifestyle_vision: Optional[str] = None
    intellectual_interests: Optional[List[str]] = None
    learning_style: Optional[str] = None
    time_availability: Optional[str] = None
    nickname: Optional[str] = None
    avatar: Optional[str] = None

@app.get("/")
async def root():
    return {"message": "Mindscroll AI Health Pipeline API"}

@app.post("/generate-summary-from-user-data")
async def generate_summary_from_user_data(user_data: UserData):
    """
    Generate a daily health summary from user-provided data
    """
    try:
        # Convert Pydantic model to dict
        user_data_dict = user_data.model_dump()
        
        # Generate summary
        summary = orchestrator.generate_daily_summary(user_data_dict)
        
        return summary
        
    except Exception as e:
        print(f"Error generating summary: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to generate summary: {str(e)}")

# User Management Endpoints
@app.post("/auth/signup")
async def signup(request: SignupRequest):
    """
    Create a new user account with AI-generated goal
    """
    try:
        # Check if user already exists
        existing_user = user_service.get_user_by_email(request.email)
        if existing_user:
            raise HTTPException(status_code=400, detail="User already exists")
        
        # Create credentials and profile
        credentials = UserCredentials(email=request.email, password=request.password)
        profile = UserProfile(
            name=request.name,
            age=request.age,
            gender=request.gender,
            weight=request.weight,
            height=request.height,
            activity_level=request.activity_level,
            medical_conditions=[],
            dietary_restrictions=[],
            
            # Health Goals and Motivation
            primary_health_goal=request.primary_health_goal,
            motivation=request.motivation,
            lifestyle_vision=request.lifestyle_vision,
            
            # Intellectual Interests
            intellectual_interests=request.intellectual_interests,
            learning_style=request.learning_style,
            time_availability=request.time_availability
        )
        
        # Create user with AI-generated goal
        user = user_service.create_user(credentials, profile)
        
        # Generate nickname and avatar
        from agents.personalization_generator import PersonalizationGenerator
        personalization_gen = PersonalizationGenerator()
        nickname, avatar = personalization_gen.generate_nickname_and_avatar(user.profile, user.goal)
        
        # Update user profile with nickname and avatar
        user.profile.nickname = nickname
        user.profile.avatar = avatar
        user_service.save_user(user)
        
        return {
            "user_id": user.id,
            "name": user.profile.name,
            "nickname": user.profile.nickname,
            "avatar": user.profile.avatar,
            "goal": user.goal.model_dump(),
            "message": "Account created successfully with personalized goal!"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create account: {str(e)}")

@app.post("/auth/login")
async def login(request: LoginRequest):
    """
    Authenticate user and return user data
    """
    try:
        user = user_service.authenticate_user(request.email, request.password)
        if not user:
            raise HTTPException(status_code=401, detail="Invalid credentials")
        
        return {
            "user_id": user.id,
            "name": user.profile.name,
            "nickname": user.profile.nickname,
            "avatar": user.profile.avatar,
            "email": user.credentials.email,
            "age": user.profile.age,
            "gender": user.profile.gender,
            "weight": user.profile.weight,
            "height": user.profile.height,
            "activity_level": user.profile.activity_level,
            "medical_conditions": user.profile.medical_conditions,
            "dietary_restrictions": user.profile.dietary_restrictions,
            "goal": user.goal.model_dump(),
            "progress": user_service.get_user_progress_summary(user.id)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Login failed: {str(e)}")

@app.get("/user/{user_id}")
async def get_user(user_id: str):
    """
    Get user profile and progress
    """
    try:
        user = user_service.get_user_by_id(user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        return {
            "user_id": user.id,
            "name": user.profile.name,
            "goal": user.goal.model_dump(),
            "progress": user_service.get_user_progress_summary(user.id)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get user: {str(e)}")

@app.post("/daily-entry")
async def add_daily_entry(request: DailyEntryRequest):
    """
    Add a daily entry for a user
    """
    try:
        success = user_service.add_daily_entry(
            request.user_id,
            request.meals,
            request.exercises,
            request.lifestyle
        )
        
        if not success:
            raise HTTPException(status_code=404, detail="User not found")
        
        return {"message": "Daily entry added successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to add daily entry: {str(e)}")

@app.post("/generate-personalized-summary")
async def generate_personalized_summary(request: DailyEntryRequest):
    """
    Generate personalized daily summary for a user
    """
    try:
        print(f"[DEBUG] Received request for user_id: {request.user_id}")
        
        # Get user
        user = user_service.get_user_by_id(request.user_id)
        if not user:
            print(f"[ERROR] User not found: {request.user_id}")
            raise HTTPException(status_code=404, detail="User not found")
        
        print(f"[DEBUG] User found: {user.profile.name}")
        
        # Add daily entry (skip if it fails)
        try:
            user_service.add_daily_entry(
                request.user_id,
                request.meals,
                request.exercises,
                request.lifestyle
            )
            print("[DEBUG] Daily entry added successfully")
        except Exception as entry_error:
            print(f"[WARNING] Failed to add daily entry: {entry_error}")
            # Continue anyway - we can still generate summary
        
        # Generate personalized summary
        user_data = {
            "meals": request.meals,
            "exercises": request.exercises,
            "lifestyle": request.lifestyle
        }
        
        print("[DEBUG] Calling enhanced orchestrator...")
        summary = enhanced_orchestrator.generate_personalized_summary(user, user_data)
        print("[DEBUG] Summary generated successfully")
        
        return summary
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"[ERROR] Exception in generate_personalized_summary: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Failed to generate personalized summary: {str(e)}")

@app.get("/user/{user_id}/progress")
async def get_user_progress(user_id: str, days: int = 7):
    """
    Get user's progress history
    """
    try:
        user = user_service.get_user_by_id(user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        recent_entries = user_service.get_recent_entries(user_id, days)
        
        return {
            "user_id": user_id,
            "recent_entries": [entry.model_dump() for entry in recent_entries],
            "progress_summary": user_service.get_user_progress_summary(user_id)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get progress: {str(e)}")

@app.put("/user/profile")
async def update_user_profile(request: ProfileUpdateRequest):
    """Update user profile and regenerate AI goal"""
    try:
        # Get current user
        user = user_service.get_user_by_id(request.user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        # Update profile with new data (only non-None values)
        update_data = {}
        if request.name is not None:
            update_data["name"] = request.name
        if request.age is not None:
            update_data["age"] = request.age
        if request.gender is not None:
            update_data["gender"] = request.gender
        if request.weight is not None:
            update_data["weight"] = request.weight
        if request.height is not None:
            update_data["height"] = request.height
        if request.activity_level is not None:
            update_data["activity_level"] = request.activity_level
        if request.primary_health_goal is not None:
            update_data["primary_health_goal"] = request.primary_health_goal
        if request.motivation is not None:
            update_data["motivation"] = request.motivation
        if request.lifestyle_vision is not None:
            update_data["lifestyle_vision"] = request.lifestyle_vision
        if request.intellectual_interests is not None:
            update_data["intellectual_interests"] = request.intellectual_interests
        if request.learning_style is not None:
            update_data["learning_style"] = request.learning_style
        if request.time_availability is not None:
            update_data["time_availability"] = request.time_availability
        if request.nickname is not None:
            update_data["nickname"] = request.nickname
        if request.avatar is not None:
            update_data["avatar"] = request.avatar
        
        # Update user profile
        updated_user = user_service.update_user_profile(request.user_id, update_data)
        if not updated_user:
            raise HTTPException(status_code=404, detail="User not found")
        
        # Regenerate AI goal based on updated profile
        from agents.goal_generator import GoalGenerator
        goal_generator = GoalGenerator()
        new_goal = goal_generator.generate_goal(updated_user.profile)
        
        # Update user's goal
        updated_user.goal = new_goal
        user_service.save_user(updated_user)
        
        return {
            "message": "Profile updated successfully with new AI-generated goal!",
            "user": {
                "user_id": updated_user.id,
                "name": updated_user.profile.name,
                "nickname": updated_user.profile.nickname,
                "avatar": updated_user.profile.avatar,
                "email": updated_user.credentials.email,
                "age": updated_user.profile.age,
                "gender": updated_user.profile.gender,
                "weight": updated_user.profile.weight,
                "height": updated_user.profile.height,
                "activity_level": updated_user.profile.activity_level,
                "medical_conditions": updated_user.profile.medical_conditions,
                "dietary_restrictions": updated_user.profile.dietary_restrictions
            },
            "goal": {
                "goal_type": updated_user.goal.goal_type,
                "target_weight": updated_user.goal.target_weight,
                "target_calories_per_day": updated_user.goal.target_calories_per_day,
                "target_protein_per_day": updated_user.goal.target_protein_per_day,
                "target_exercise_minutes_per_week": updated_user.goal.target_exercise_minutes_per_week,
                "target_sleep_hours": updated_user.goal.target_sleep_hours,
                "target_screen_time_hours": updated_user.goal.target_screen_time_hours,
                "target_stress_level": updated_user.goal.target_stress_level,
                "goal_description": updated_user.goal.goal_description,
                "ai_generated": True,
                "created_at": updated_user.goal.created_at
            }
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to update profile: {str(e)}")

# MongoDB connection is handled by SyncMongoDBUserService

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)